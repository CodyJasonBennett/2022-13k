import * as glslx from 'glslx'
// @ts-ignore
import htmlMinify from 'html-minifier-terser'
import { InputAction, InputType, Packer } from 'roadroller'
import type { OutputChunk } from 'rollup'
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    target: 'esnext',
    polyfillModulePreload: false,
  },
  plugins: [
    {
      name: 'vite-glsl',
      generateBundle(_, bundle) {
        for (const key in bundle) {
          const entry = bundle[key] as OutputChunk
          const shaders = Array.from(entry.code.matchAll(/#version[^`]+/gm)).map(([match]) => match)

          for (let i = 0; i < shaders.length; i += 2) {
            const vertex = shaders[i]
            const fragment = shaders[i + 1]

            for (const shader of [vertex, fragment]) {
              const compiled = glslx.compile(
                shader
                  .replace('#version 300 es', '#version 100')
                  .replaceAll('texture(', 'texture2D(')
                  .replaceAll(/[^\w]?(in|out) /gm, (_, type) => `varying ${type === 'in' ? 'highp' : 'mediump'} `),
                { renaming: 'none' }, // TODO: safely rename varyings
              )
              if (compiled.log) throw compiled.log

              const minified = JSON.parse(compiled.output!)
                .shaders[0].contents.replace('#version 100', '#version 300 es')
                .replaceAll('texture2D(', 'texture(')
                .replaceAll('varying highp ', 'in ')
                .replaceAll('varying mediump ', 'out ')

              entry.code = entry.code.replaceAll(shader, minified)
            }
          }
        }
      },
    },
    {
      name: 'vite-roadroller',
      transformIndexHtml: {
        enforce: 'post',
        async transform(html, ctx) {
          if (!ctx?.bundle) return html

          let chunk!: OutputChunk
          for (const key in ctx.bundle) {
            if (key.endsWith('.js')) {
              chunk = ctx.bundle[key] as OutputChunk
              delete ctx.bundle[key]
            }
          }

          let minified = await htmlMinify.minify(html, {
            includeAutoGeneratedTags: true,
            removeAttributeQuotes: true,
            removeComments: true,
            removeRedundantAttributes: true,
            removeScriptTypeAttributes: true,
            removeStyleLinkTypeAttributes: true,
            sortClassName: true,
            useShortDoctype: true,
            collapseWhitespace: true,
            collapseInlineTagWhitespace: true,
            removeEmptyAttributes: true,
            removeOptionalTags: true,
            sortAttributes: true,
            minifyCSS: true,
          })

          minified = minified.replace(new RegExp(`<script[^>]*?src=[\\./]*${chunk.fileName}[^>]*?></script>`), '')

          const packer = new Packer(
            [
              {
                data: chunk.code.trim(),
                type: 'js' as InputType,
                action: 'eval' as InputAction,
              },
            ],
            {},
          )

          await packer.optimize(2)

          const { firstLine, secondLine } = packer.makeDecoder()
          return `${minified}<body><script>${firstLine}\n${secondLine}</script></body>`
        },
      },
    },
  ],
})
